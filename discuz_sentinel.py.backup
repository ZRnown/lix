#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DiscuzSentinel - Discuz! è®ºå›å¤šé©¿ç«™ç›‘æ§ç³»ç»Ÿ
ã€é£ä¹¦åŸç”Ÿå›¾é€‚é…ç‰ˆã€‘
1. é’‰é’‰ï¼šä½¿ç”¨ Catbox/CF å¤–é“¾ç›´æ¥æ˜¾ç¤º
2. é£ä¹¦ï¼šè‡ªåŠ¨å°†å›¾ç‰‡ä¸Šä¼ åˆ°é£ä¹¦æœåŠ¡å™¨ (éœ€é…ç½® AppID)ï¼Œå®ç°åŸç”Ÿå¤§å›¾æ˜¾ç¤º
"""

import json
import logging
from logging.handlers import TimedRotatingFileHandler
import os
import random
import re
import time
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from urllib.parse import urljoin
import urllib.parse
import hmac
import hashlib
import base64
import requests
from bs4 import BeautifulSoup

# å°è¯•åŠ è½½ python-dotenv
try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    pass

# ==================== é…ç½®åŒºåŸŸ ====================

# ç›®æ ‡é©¿ç«™ FID åˆ—è¡¨
TARGET_FIDS_STR = os.getenv('DISCUZ_TARGET_FIDS', '147,148')
TARGET_FIDS = [int(fid.strip()) for fid in TARGET_FIDS_STR.split(',') if fid.strip()]

# Cookie
COOKIE = os.getenv('DISCUZ_COOKIE', 'your_cookie_here')

# é’‰é’‰é…ç½®
DINGTALK_WEBHOOK = os.getenv('DINGTALK_WEBHOOK', '')
DINGTALK_SECRET = os.getenv('DINGTALK_SECRET', '')

# é£ä¹¦é…ç½® (Webhook å¿…é¡»å¡«)
FEISHU_WEBHOOK = os.getenv('FEISHU_WEBHOOK', '')

# é£ä¹¦ App é…ç½® (â˜… å¡«å…¥è¿™ä¸¤é¡¹æ‰èƒ½ç›´æ¥æ˜¾ç¤ºå›¾ç‰‡ â˜…)
FEISHU_APP_ID = os.getenv('FEISHU_APP_ID', '')      # ä¾‹å¦‚: cli_a4d9...
FEISHU_APP_SECRET = os.getenv('FEISHU_APP_SECRET', '') # ä¾‹å¦‚: 8F3...

# æ‚¨çš„å›¾åºŠ (Cloudflare Pages)
ZYCS_IMG_HOST = os.getenv('ZYCS_IMG_HOST', 'https://zycs-img-4sd.pages.dev')

# åŸºç¡€é…ç½®
PREVIEW_LIMIT = int(os.getenv('PREVIEW_LIMIT', '4000'))
BASE_URL = "https://www.55188.com"
STATE_FILE = "monitor_state.json"
LOG_FILE = os.getenv('LOG_FILE', 'discuz_sentinel.log')
LOG_LEVEL = logging.INFO
LOG_RETENTION_DAYS = 7

class DiscuzSentinel:
    def __init__(self):
        self._setup_logging()
        self.session = requests.Session()
        self.state = self._load_state()
        self._setup_session()
        # é£ä¹¦ Token ç¼“å­˜
        self.feishu_token = ""
        self.feishu_token_expire = 0.0
        self._check_config()

    def _setup_logging(self):
        handlers = [logging.StreamHandler()]
        if LOG_FILE:
        if LOG_FILE:
            file_handler = TimedRotatingFileHandler(
                LOG_FILE, when="midnight", backupCount=LOG_RETENTION_DAYS, encoding='utf-8'
            )
            handlers.append(file_handler)

    def _setup_session(self):
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Connection': 'keep-alive',
            'Cookie': COOKIE
        })

    def _load_state(self) -> Dict:
        try:
            with open(STATE_FILE, 'r', encoding='utf-8') as f:
                state = json.load(f)
                normalized = {}
                for k, v in state.items():
                    fid = int(k)
                    if isinstance(v, dict):
                        normalized[fid] = {'last_pid': int(v.get('last_pid', 0)), 'last_tid': int(v.get('last_tid', 0))}
                    else:
                        normalized[fid] = {'last_pid': int(v), 'last_tid': 0}
                return normalized
        except FileNotFoundError:
            return {}
        except Exception:
            return {}

    def _save_state(self):
        try:
            with open(STATE_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.state, f, ensure_ascii=False, indent=2)
        except Exception as e:
            self.logger.error(f"ä¿å­˜çŠ¶æ€å¤±è´¥: {e}")
    
    def _check_config(self):
        if not COOKIE or COOKIE == 'your_cookie_here':
            self.logger.warning("âŒ Cookie æœªé…ç½®")
        if not DINGTALK_WEBHOOK and not FEISHU_WEBHOOK:
            self.logger.warning("âš ï¸  æœªé…ç½®ä»»ä½•é€šçŸ¥ Webhook")
        if FEISHU_WEBHOOK and not FEISHU_APP_ID:
            self.logger.warning("âš ï¸  é£ä¹¦æœªé…ç½® AppID/Secretï¼Œå›¾ç‰‡å°†æ— æ³•ç›´æ¥æ˜¾ç¤ºï¼Œä»…æ˜¾ç¤ºé“¾æ¥")

    def _get_livelastpost(self, fid: int, last_pid: int) -> Optional[Dict]:
        url = f"{BASE_URL}/forum.php"
        params = {'mod': 'misc', 'action': 'livelastpost', 'type': 'post', 'fid': fid, 'postid': last_pid}
        headers = {'Referer': f"{BASE_URL}/group-{fid}-1.html", 'Accept': 'application/json', 'X-Requested-With': 'XMLHttpRequest'}

        # æ·»åŠ é‡è¯•æœºåˆ¶ï¼Œæœ€å¤šé‡è¯•2æ¬¡
        for attempt in range(3):
            try:
                self.logger.debug(f"FID {fid}: è¯·æ±‚ livelastpost (å°è¯• {attempt + 1}/3)")
                response = self.session.get(url, params=params, headers=headers, timeout=15)

                # æ£€æŸ¥HTTPçŠ¶æ€ç 
                if response.status_code == 504:
                    self.logger.warning(f"FID {fid}: æœåŠ¡å™¨ç½‘å…³è¶…æ—¶ (504)ï¼Œè®ºå›æœåŠ¡å™¨å¯èƒ½è´Ÿè½½è¿‡é«˜æˆ–ç»´æŠ¤ä¸­")
                    if attempt < 2:  # ä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•
                        self.logger.info(f"FID {fid}: {5 * (attempt + 1)} ç§’åé‡è¯•...")
                        time.sleep(5 * (attempt + 1))
                        continue
                    return None

                if response.status_code != 200:
                    self.logger.warning(f"FID {fid}: HTTP {response.status_code} é”™è¯¯")
                    return None

                # æ£€æŸ¥å“åº”å†…å®¹æ˜¯å¦åŒ…å«ç™»å½•æç¤º
            response_text = response.text
                if 'not_loggedin' in response_text:
                    self.logger.warning(f"FID {fid}: Cookie å¯èƒ½å·²å¤±æ•ˆ")
                return None
            
                if '504 Gateway Time-out' in response_text:
                    self.logger.warning(f"FID {fid}: å“åº”å†…å®¹æ˜¾ç¤ºç½‘å…³è¶…æ—¶")
                    if attempt < 2:
                        self.logger.info(f"FID {fid}: {5 * (attempt + 1)} ç§’åé‡è¯•...")
                        time.sleep(5 * (attempt + 1))
                        continue
                    return None

                # å°è¯•è§£æJSON
            try:
                data = response.json()
            except json.JSONDecodeError as e:
                    self.logger.warning(f"FID {fid}: å“åº”ä¸æ˜¯æœ‰æ•ˆJSON: {e}")
                    self.logger.debug(f"FID {fid}: å“åº”å†…å®¹å‰200å­—ç¬¦: {response_text[:200]}")
                return None
            
                count = int(data.get('count', 0))
                if count > 0:
            self.logger.info(f"FID {fid}: å‘ç° {count} æ¡æ–°å†…å®¹")
            return data
                else:
                    self.logger.debug(f"FID {fid}: æš‚æ— æ–°å†…å®¹ (count={count})")
                    return None
            
        except requests.exceptions.Timeout:
                self.logger.warning(f"FID {fid}: è¯·æ±‚è¶…æ—¶ (å°è¯• {attempt + 1}/3)")
                if attempt < 2:
                    time.sleep(3)
                    continue
            return None

        except requests.exceptions.RequestException as e:
                self.logger.error(f"FID {fid}: ç½‘ç»œè¯·æ±‚å¼‚å¸¸: {e}")
                if attempt < 2:
                    time.sleep(3)
                    continue
            return None

        except Exception as e:
                self.logger.error(f"FID {fid}: å¤„ç† livelastpost æ—¶å‡ºç°å¼‚å¸¸: {e}")
            return None

        return None

    def _get_thread_detail(self, tid: int, target_pid: Optional[int]) -> Optional[Dict]:
        url = f"{BASE_URL}/api/mobile/index.php"
        params = {'version': '4', 'module': 'viewthread', 'tid': tid}
        try:
            response = self.session.get(url, params=params, timeout=15)
            data = response.json()
            if 'show_thread_nopermission' in str(data):
                return self._get_web_content_fallback(tid, fid_hint=None)
            if target_pid:
                found = False
                for post in data.get('Variables', {}).get('postlist', []):
                    if int(post.get('pid', 0)) == target_pid: found = True
                if not found: return self._get_web_content_fallback(tid, fid_hint=None)
            return data
        except Exception:
            return self._get_web_content_fallback(tid, fid_hint=None)

    def _extract_post_content(self, thread_data: Dict, target_pid: int) -> Optional[Dict]:
        try:
            if not isinstance(thread_data, dict): return None
            vars = thread_data.get('Variables', {})
            post_list = vars.get('postlist', [])
            target = next((p for p in post_list if int(p.get('pid', 0)) == target_pid), None)
            if not target: return None
            
            subject = vars.get('thread', {}).get('subject', 'æ— æ ‡é¢˜')
            text, images = self._clean_content(target.get('message', ''))
            return {
                'subject': subject,
                'author': target.get('author', 'æœªçŸ¥'),
                'time': target.get('dateline', ''),
                'content': text,
                'images': images,
                'url': f"{BASE_URL}/thread-{vars.get('thread', {}).get('tid', '')}-1-1.html"
            }
        except Exception:
        return None

    def _extract_from_livelastpost(self, post_item: Dict, fid: int) -> Optional[Dict]:
        text, images = self._clean_content(post_item.get('message', ''))
        tid = self._extract_tid_from_message(post_item.get('message', ''))
            return {
            'subject': text[:30] + '...' if text else 'æ–°åŠ¨æ€',
            'author': post_item.get('author', 'æœªçŸ¥'),
            'time': post_item.get('dateline', ''),
            'content': text,
                'images': images,
            'url': f"{BASE_URL}/thread-{tid}-1-1.html" if tid else f"{BASE_URL}/group-{fid}-1.html"
            }

    def _get_web_content_fallback(self, tid: int, fid_hint: Optional[int]) -> Tuple[Optional[str], Optional[List[str]]]:
        url = f"{BASE_URL}/thread-{tid}-1-1.html"
        try:
            resp = self.session.get(url, timeout=15)
            if resp.encoding.lower() in ['gbk', 'gb2312']: resp.encoding = 'gbk'
            soup = BeautifulSoup(resp.text, 'html.parser')
            node = soup.find('td', class_='t_f')
            if not node: return "è§£æå¤±è´¥", []
            text = node.get_text(separator='\n').strip()
            images = []
            for img in node.find_all('img'):
                src = img.get('zoomfile') or img.get('file') or img.get('src')
                if src: images.append(urljoin(BASE_URL + '/', src))
            return text, images
        except Exception:
            return None, None

    def _clean_content(self, html_content: str) -> Tuple[str, List[str]]:
        if not html_content: return "", []
        soup = BeautifulSoup(html_content, 'html.parser')
        images = []
        for img in soup.find_all('img'):
            src = img.get('zoomfile') or img.get('file') or img.get('src')
            if src and 'smilies' not in src:
                images.append(urljoin(BASE_URL + '/', src))
        for tag in soup(['script', 'style', 'img']):
            tag.decompose()
        return soup.get_text('\n').strip(), images

    def _extract_tid_from_message(self, html: str) -> Optional[int]:
        m = re.search(r'thread-(\d+)', html)
        return int(m.group(1)) if m else None

    def _format_message(self, post_data: Dict) -> str:
        t = post_data.get('time', '')
        if str(t).isdigit(): t = datetime.fromtimestamp(int(t)).strftime('%Y-%m-%d %H:%M:%S')
        content = post_data.get('content', '')
        if PREVIEW_LIMIT > 0: content = content[:PREVIEW_LIMIT]
        return f"### {post_data.get('subject')}\n**ä½œè€…**: {post_data.get('author')}  **æ—¶é—´**: {t}\n\n{content}\n\n[ğŸ”— æŸ¥çœ‹åŸå¸–]({post_data.get('url')})"

    # ================= é’‰é’‰ä¸“ç”¨ï¼šå…¨èƒ½å¤–é“¾ä¸Šä¼  =================
    def _universal_upload_for_dingtalk(self, img_url: str) -> str:
        """
        ä¸Šä¼ åˆ°è‡ªå»ºå›¾åºŠï¼šhttp://frp-cup.com:12245/upload/upload.html
        """
        try:
            headers = {"Referer": BASE_URL + "/", "User-Agent": self.session.headers.get("User-Agent")}
            r = self.session.get(img_url, headers=headers, timeout=15)
            if r.status_code != 200: return img_url
            if len(r.content) < 100 or r.content.strip().startswith(b'<'): return img_url
            img_content = r.content
        except: return img_url

        # ç¡®å®šMIMEç±»å‹å’Œæ‰©å±•å
        mime = 'image/jpeg'
        ext = '.jpg'
        if img_content.startswith(b'\x89PNG'): mime, ext = 'image/png', '.png'
        elif img_content.startswith(b'GIF8'): mime, ext = 'image/gif', '.gif'
        filename = f"img_{int(time.time())}_{random.randint(100,999)}{ext}"

        # è‡ªå»ºå›¾åºŠä¸Šä¼ ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
        for attempt in range(5):  # æœ€å¤šé‡è¯•5æ¬¡
            try:
                upload_url = "http://frp-cup.com:12245/upload/upload.html"

                # æ„å»ºmultipart/form-data
                files = {'image': (filename, img_content, mime)}

                # è®¾ç½®è¯·æ±‚å¤´
                headers = {
                    'Accept': 'application/json, text/javascript, */*; q=0.01',
                    'Accept-Language': 'en-US,en;q=0.9,zh-HK;q=0.8,zh-CN;q=0.7,zh;q=0.6',
                    'Connection': 'keep-alive',
                    'Origin': 'http://frp-cup.com:12245',
                    'Referer': 'http://frp-cup.com:12245/',
                    'User-Agent': self.session.headers.get("User-Agent"),
                    'X-Requested-With': 'XMLHttpRequest'
                }

                self.logger.debug(f"[è‡ªå»ºå›¾åºŠ] å°è¯•ä¸Šä¼  {filename} (å°è¯• {attempt + 1}/5)")

                # å‘é€ä¸Šä¼ è¯·æ±‚ï¼ˆå…è®¸ä¸å®‰å…¨çš„SSLè¯ä¹¦ï¼Œå»¶é•¿è¶…æ—¶æ—¶é—´ï¼‰
                # å¯¹äºå›¾ç‰‡ä¸Šä¼ ï¼ŒæœåŠ¡å™¨å¯èƒ½éœ€è¦æ›´å¤šæ—¶é—´å¤„ç†
                upload_timeout = 90 if attempt == 0 else 60  # ç¬¬ä¸€æ¬¡å°è¯•90ç§’ï¼Œåç»­60ç§’
                res = requests.post(upload_url, files=files, headers=headers, timeout=upload_timeout, verify=False)

                # æ£€æŸ¥HTTPçŠ¶æ€ç 
                if res.status_code == 200:
                    try:
                        data = res.json()
                        if data.get('code') == 200 and 'data' in data:
                            img_url_result = data['data'].get('url')
                            if img_url_result:
                                # URLä¸­çš„\/éœ€è¦è½¬ä¹‰
                                final_url = img_url_result.replace('\\/', '/')
                                self.logger.info(f"âœ… [è‡ªå»ºå›¾åºŠ] ä¸Šä¼ æˆåŠŸ: {final_url}")
                                return final_url
                else:
                            self.logger.warning(f"[è‡ªå»ºå›¾åºŠ] APIå“åº”é”™è¯¯: {data}")
                    except json.JSONDecodeError as e:
                        self.logger.warning(f"[è‡ªå»ºå›¾åºŠ] å“åº”ä¸æ˜¯æœ‰æ•ˆJSON: {e}")
                        self.logger.debug(f"[è‡ªå»ºå›¾åºŠ] å“åº”å†…å®¹: {res.text[:200]}")
                else:
                    self.logger.warning(f"[è‡ªå»ºå›¾åºŠ] HTTP {res.status_code} é”™è¯¯")

            except requests.exceptions.ConnectionError as e:
                if "RemoteDisconnected" in str(e) or "Connection aborted" in str(e):
                    self.logger.warning(f"[è‡ªå»ºå›¾åºŠ] è¿æ¥è¢«è¿œç¨‹ç«¯æ–­å¼€ (å°è¯• {attempt + 1}/5): {e}")
                    else:
                    self.logger.warning(f"[è‡ªå»ºå›¾åºŠ] è¿æ¥é”™è¯¯ (å°è¯• {attempt + 1}/5): {e}")
            except requests.exceptions.Timeout as e:
                self.logger.warning(f"[è‡ªå»ºå›¾åºŠ] è¯·æ±‚è¶…æ—¶ ({upload_timeout}s) (å°è¯• {attempt + 1}/5): {e}")
            except requests.exceptions.RequestException as e:
                self.logger.warning(f"[è‡ªå»ºå›¾åºŠ] ç½‘ç»œè¯·æ±‚å¼‚å¸¸ (å°è¯• {attempt + 1}/5): {e}")
                except Exception as e:
                self.logger.error(f"[è‡ªå»ºå›¾åºŠ] æœªçŸ¥å¼‚å¸¸ (å°è¯• {attempt + 1}/5): {e}")

            # å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç­‰å¾…åé‡è¯•
            if attempt < 4:
                retry_delay = 3 * (attempt + 1)  # 3ç§’, 6ç§’, 9ç§’, 12ç§’
                self.logger.info(f"[è‡ªå»ºå›¾åºŠ] {retry_delay} ç§’åé‡è¯•...")
                time.sleep(retry_delay)

        # æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥ï¼Œè¿”å›åŸé“¾æ¥
        self.logger.error("[è‡ªå»ºå›¾åºŠ] ä¸Šä¼ å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œè¿”å›åŸé“¾æ¥")
        return img_url

    # ================= é£ä¹¦ä¸“ç”¨ï¼šè·å–Tokenå¹¶ä¸Šä¼  =================
    def _get_feishu_token(self) -> Optional[str]:
        now = time.time()
        if self.feishu_token and self.feishu_token_expire > now:
            return self.feishu_token
        if not (FEISHU_APP_ID and FEISHU_APP_SECRET):
            return None
        try:
            url = "https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal"
            resp = requests.post(url, json={"app_id": FEISHU_APP_ID, "app_secret": FEISHU_APP_SECRET}, timeout=10)
            data = resp.json()
            if data.get("code") == 0:
                self.feishu_token = data["tenant_access_token"]
                self.feishu_token_expire = now + int(data.get("expire", 3600)) - 60
                return self.feishu_token
        except Exception as e:
            self.logger.error(f"é£ä¹¦ Token è·å–å¤±è´¥: {e}")
            return None

    def _upload_to_feishu_server(self, img_url: str) -> Optional[str]:
        """
        å°†å›¾ç‰‡ä¸Šä¼ åˆ°é£ä¹¦æœåŠ¡å™¨ï¼Œè·å– image_key (ç”¨äºç›´æ¥æ˜¾ç¤º)
        """
        token = self._get_feishu_token()
        if not token: return None

        try:
            # ä¸‹è½½å›¾ç‰‡
            headers = {"Referer": BASE_URL + "/", "User-Agent": self.session.headers.get("User-Agent")}
            r = self.session.get(img_url, headers=headers, timeout=15)
            if r.status_code != 200: return None
            
            # ä¸Šä¼ é£ä¹¦
            url = "https://open.feishu.cn/open-apis/im/v1/images"
            headers = {"Authorization": f"Bearer {token}"}
            # é£ä¹¦è¦æ±‚å­—æ®µåä¸º image
            files = {"image_type": (None, "message"), "image": ("image.jpg", r.content)}
            resp = requests.post(url, headers=headers, files=files, timeout=20)
            data = resp.json()
            if data.get("code") == 0:
                key = data.get("data", {}).get("image_key")
                self.logger.info(f"âœ… [é£ä¹¦] åŸç”Ÿä¸Šä¼ æˆåŠŸ key: {key}")
                return key
            else:
                self.logger.warning(f"[é£ä¹¦] ä¸Šä¼ å¤±è´¥: {data}")
        except Exception as e:
            self.logger.error(f"[é£ä¹¦] ä¸Šä¼ å¼‚å¸¸: {e}")
            return None

    # ================= å‘é€é€»è¾‘ =================

    def send_dingtalk(self, message: str, post_data: Dict = None) -> bool:
        webhook_url = DINGTALK_WEBHOOK
        if not webhook_url: return False

        final_markdown = message
        # é’‰é’‰ä½¿ç”¨å¤–é“¾
        if post_data and post_data.get('images'):
            self.logger.info(f"é’‰é’‰ï¼šæ­£åœ¨å¤„ç† {len(post_data['images'])} å¼ å›¾ç‰‡...")
            for img_url in post_data['images']:
                new_url = self._universal_upload_for_dingtalk(img_url)
                if new_url != img_url:
                    final_markdown += f"\n\n![å›¾ç‰‡]({new_url})"
                else:
                    final_markdown += f"\n\n[ğŸ–¼ï¸ å›¾ç‰‡æ— æ³•é¢„è§ˆ]({img_url})"
                time.sleep(0.5)

        # åŠ ç­¾
        if DINGTALK_SECRET:
            timestamp = str(round(time.time() * 1000))
            string_to_sign = f"{timestamp}\n{DINGTALK_SECRET}"
            hmac_code = hmac.new(DINGTALK_SECRET.encode('utf-8'), string_to_sign.encode('utf-8'), digestmod=hashlib.sha256).digest()
            sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))
            delimiter = '&' if '?' in webhook_url else '?'
            webhook_url = f"{webhook_url}{delimiter}timestamp={timestamp}&sign={sign}"

        try:
            payload = {
                "msgtype": "markdown",
                "markdown": {"title": post_data.get('subject', 'æ–°åŠ¨æ€'), "text": final_markdown}
            }
            requests.post(webhook_url, json=payload, timeout=10)
            return True
            except Exception as e:
            self.logger.error(f"é’‰é’‰å‘é€å¼‚å¸¸: {e}")
            return False

    def send_feishu(self, message: str, post_data: Dict = None) -> bool:
        webhook_url = FEISHU_WEBHOOK
        if not webhook_url: return False

        elements = [
            {
                "tag": "div",
                "text": {
                    "tag": "lark_md",
                    "content": message
                }
            }
        ]

        # é£ä¹¦å›¾ç‰‡å¤„ç†
        if post_data and post_data.get('images'):
            self.logger.info(f"é£ä¹¦ï¼šæ­£åœ¨å¤„ç† {len(post_data['images'])} å¼ å›¾ç‰‡...")
            
            if FEISHU_APP_ID and FEISHU_APP_SECRET:
                # æ–¹å¼Aï¼šé…ç½®äº† AppID -> ä¸Šä¼ åˆ°é£ä¹¦ -> ä½¿ç”¨ image æ ‡ç­¾æ˜¾ç¤ºå¤§å›¾
                for img_url in post_data['images']:
                    image_key = self._upload_to_feishu_server(img_url)
                    if image_key:
                        elements.append({
                            "tag": "img",
                            "img_key": image_key,
                            "alt": {"tag": "plain_text", "content": "å›¾ç‰‡"}
                        })
                    time.sleep(0.5)
        else:
                # æ–¹å¼Bï¼šæ²¡é…ç½® AppID -> ä½¿ç”¨ Catbox å¤–é“¾ -> æ˜¾ç¤ºä¸ºç‚¹å‡»é“¾æ¥
                # (å› ä¸ºé£ä¹¦ Webhook æ— æ³•ç›´æ¥æ¸²æŸ“å¤–é“¾å›¾ç‰‡)
                for img_url in post_data['images']:
                    new_url = self._universal_upload_for_dingtalk(img_url)
                    elements.append({
                        "tag": "div",
                        "text": {
                            "tag": "lark_md",
                            "content": f"[ğŸ–¼ï¸ ç‚¹å‡»æŸ¥çœ‹å›¾ç‰‡]({new_url})"
                        }
                    })

        elements.append({"tag": "hr"})
        elements.append({
            "tag": "note",
            "elements": [{"tag": "plain_text", "content": f"DiscuzSentinel â€¢ {datetime.now().strftime('%H:%M:%S')}"}]
        })

        payload = {
            "msg_type": "interactive",
            "card": {
                "config": {"wide_screen_mode": True},
                "header": {
                    "title": {"tag": "plain_text", "content": post_data.get('subject', 'æ–°åŠ¨æ€')},
                    "template": "blue"
                },
                "elements": elements
            }
        }

        try:
            requests.post(webhook_url, json=payload, timeout=10)
                return True
        except Exception as e:
            self.logger.error(f"é£ä¹¦å‘é€å¼‚å¸¸: {e}")
            return False
    
    def run(self):
        self.logger.info(f"DiscuzSentinel å¯åŠ¨ | ç›‘æ§: {TARGET_FIDS}")
        if not (FEISHU_APP_ID and FEISHU_APP_SECRET):
            self.logger.warning("æç¤º: é£ä¹¦æœªé…ç½® AppID/Secretï¼Œå›¾ç‰‡å°†ä»¥é“¾æ¥å½¢å¼å±•ç¤ºã€‚é…ç½®åå¯ç›´æ¥æ˜¾ç¤ºå¤§å›¾ã€‚")

        while True:
            try:
                for fid in TARGET_FIDS:
                    fid_state = self.state.get(fid, {'last_pid': 0})
                    data = self._get_livelastpost(fid, fid_state.get('last_pid', 0))
                    if data:
                        # æ”¶é›†æ‰€æœ‰æ–°å¸–å­ï¼ŒæŒ‰æ—¶é—´é¡ºåºæ’åº
                        new_posts = []
                        max_pid = fid_state.get('last_pid', 0)

                        # é¦–å…ˆæŒ‰ PID ä»å°åˆ°å¤§å¤„ç†ï¼Œç¡®ä¿ä¸é—æ¼
                        for item in sorted(data.get('list', []), key=lambda x: int(x.get('pid', 0))):
                            pid = int(item.get('pid', 0))
                            if pid <= max_pid:
                    continue
                
                            # è·å–å¸–å­æ•°æ®
                            post_data = self._extract_from_livelastpost(item, fid)
                            tid = self._extract_tid_from_message(item.get('message', ''))
                if tid:
                                detail = self._get_thread_detail(tid, pid)
                                if detail:
                                    extracted = self._extract_post_content(detail, pid)
                                    if extracted:
                                        post_data = extracted

                        if post_data:
                                # æ·»åŠ æ—¶é—´æˆ³ç”¨äºæ’åº
                                post_data['_timestamp'] = self._parse_timestamp(post_data.get('time', ''))
                                post_data['_pid'] = pid
                                new_posts.append(post_data)

                            max_pid = max(max_pid, pid)

                        # å¦‚æœæœ‰æ–°å¸–å­ï¼ŒæŒ‰æ—¶é—´é¡ºåºæ’åºå¹¶ç«‹å³æ¨é€
                        if new_posts:
                            # æŒ‰æ—¶é—´æˆ³ä»å°åˆ°å¤§æ’åºï¼ˆæ—§æ—¶é—´åœ¨å‰ï¼‰
                            new_posts.sort(key=lambda x: x['_timestamp'])

                            self.logger.info(f"FID {fid}: å‘ç° {len(new_posts)} æ¡æ–°å†…å®¹ï¼Œå¼€å§‹æŒ‰æ—¶é—´é¡ºåºæ¨é€")

                            for post_data in new_posts:
                                msg = self._format_message(post_data)
                                pid = post_data['_pid']

                                # é’‰é’‰æ¨é€
                                if DINGTALK_WEBHOOK:
                                    self.send_dingtalk(msg, post_data)
                                # é£ä¹¦æ¨é€
                                if FEISHU_WEBHOOK:
                                    time.sleep(1)
                                    self.send_feishu(msg, post_data)

                                self.logger.info(f"å·²æ¨é€ PID {pid} (æ—¶é—´: {post_data.get('time', 'æœªçŸ¥')})")

                                # æ¨é€é—´éš”ï¼Œé¿å…è§¦å‘é™æµ
            time.sleep(1.5)

            # æ›´æ–°çŠ¶æ€
                            self.state.setdefault(fid, {})['last_pid'] = max_pid
            self._save_state()

                    time.sleep(3)
                time.sleep(random.randint(30, 60))
            except KeyboardInterrupt:
                break
            except Exception as e:
                self.logger.error(f"ä¸»å¾ªç¯å¼‚å¸¸: {e}")
                time.sleep(60)

    def _parse_timestamp(self, time_str: str) -> float:
        """
        è§£ææ—¶é—´å­—ç¬¦ä¸²ä¸ºæ—¶é—´æˆ³ï¼Œç”¨äºæ’åº
        """
        if not time_str:
            return 0.0

        # å¦‚æœå·²ç»æ˜¯æ•°å­—æ—¶é—´æˆ³
        if str(time_str).isdigit():
            try:
                return float(time_str)
            except:
                pass

        # å¦‚æœæ˜¯æ ¼å¼åŒ–çš„æ—¶é—´å­—ç¬¦ä¸²ï¼Œå°è¯•è§£æ
        try:
            # å¸¸è§çš„æ ¼å¼ï¼š2025-12-25 13:08:20
            if isinstance(time_str, str):
                dt = datetime.strptime(time_str, '%Y-%m-%d %H:%M:%S')
                return dt.timestamp()
        except:
            pass

        # å¦‚æœè§£æå¤±è´¥ï¼Œè¿”å›å½“å‰æ—¶é—´æˆ³ä½œä¸ºé»˜è®¤å€¼
        return time.time()

if __name__ == "__main__":
    DiscuzSentinel().run()